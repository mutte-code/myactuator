# This file was autogenerated by "motor_commands_generator.py" found under the "motor_command_generation" folder of "myactuator_lib"
import can

class _MyActuatorMotorPrivate():

	def __init__(self, arbitration_id: int):
		minimum_id = 0x141
		maximum_id = 0x172

		if (minimum_id < arbitration_id < maximum_id): 
			self.arbitration_id = arbitration_id
		else:
			raise ValueError(f"The arbitration id {arbitration_id} is invalid")

	def _create_can_message(self, cmd_byte: int, can_data: list[int]) -> can.Message:

		if not (len(can_data) == 7): # need to populate 7 bytes only, check
			raise ValueError

		for byte in can_data:
			if not (0x00 <= byte <= 0xFF): # int not guaranteed to be within range of hex byte, check
				raise ValueError

		can_data = cmd_byte + can_data # construct can message, and return
		return can.Message(
			arbitration_id = self.arbitration_id,
			is_extended_id = False,
			data = can_data)

	def Read_PID_parameter_command(self, can_msg_inputs: list[int]) -> can.Message:
		cmd_byte = 0x30
		self._create_can_message(cmd_byte, can_msg_inputs)

	def Write_PID_parameters_to_RAM_command(self, can_msg_inputs: list[int]) -> can.Message:
		cmd_byte = 0x31
		self._create_can_message(cmd_byte, can_msg_inputs)

	def Write_PID_parameters_to_ROM_command(self, can_msg_inputs: list[int]) -> can.Message:
		cmd_byte = 0x32
		self._create_can_message(cmd_byte, can_msg_inputs)

	def Read_acceleration_command(self, can_msg_inputs: list[int]) -> can.Message:
		cmd_byte = 0x42
		self._create_can_message(cmd_byte, can_msg_inputs)

	def Write_acceleration_to_RAM_and_ROM_command(self, can_msg_inputs: list[int]) -> can.Message:
		cmd_byte = 0x43
		self._create_can_message(cmd_byte, can_msg_inputs)

	def Read_multi_turn_encoder_position_data_command(self, can_msg_inputs: list[int]) -> can.Message:
		cmd_byte = 0x60
		self._create_can_message(cmd_byte, can_msg_inputs)

	def Read_multi_turn_encoder_zero_offset_data_command(self, can_msg_inputs: list[int]) -> can.Message:
		cmd_byte = 0x62
		self._create_can_message(cmd_byte, can_msg_inputs)

	def Read_single_turn_encoder_command(self, can_msg_inputs: list[int]) -> can.Message:
		cmd_byte = 0x90
		self._create_can_message(cmd_byte, can_msg_inputs)

	def Read_multi_turn_angle_command(self, can_msg_inputs: list[int]) -> can.Message:
		cmd_byte = 0x92
		self._create_can_message(cmd_byte, can_msg_inputs)

	def Read_single_turn_angle_command(self, can_msg_inputs: list[int]) -> can.Message:
		cmd_byte = 0x94
		self._create_can_message(cmd_byte, can_msg_inputs)

	def Read_Motor_Status_and_Error_Flag_Command(self, can_msg_inputs: list[int]) -> can.Message:
		cmd_byte = 0x9A
		self._create_can_message(cmd_byte, can_msg_inputs)

	def Read_Motor_Status_Command(self, can_msg_inputs: list[int]) -> can.Message:
		cmd_byte = 0x9C
		self._create_can_message(cmd_byte, can_msg_inputs)

	def Read_Motor_Status_Command(self, can_msg_inputs: list[int]) -> can.Message:
		cmd_byte = 0x9D
		self._create_can_message(cmd_byte, can_msg_inputs)

	def Motor_shutdown_command(self, can_msg_inputs: list[int]) -> can.Message:
		cmd_byte = 0x80
		self._create_can_message(cmd_byte, can_msg_inputs)

	def Motor_stop_command(self, can_msg_inputs: list[int]) -> can.Message:
		cmd_byte = 0x81
		self._create_can_message(cmd_byte, can_msg_inputs)

	def Torque_closed_loop_control_command(self, can_msg_inputs: list[int]) -> can.Message:
		cmd_byte = 0xA1
		self._create_can_message(cmd_byte, can_msg_inputs)

	def Speed_Closed_loop_Control_Command(self, can_msg_inputs: list[int]) -> can.Message:
		cmd_byte = 0xA2
		self._create_can_message(cmd_byte, can_msg_inputs)

	def Absolute_position_closed_loop_control_command(self, can_msg_inputs: list[int]) -> can.Message:
		cmd_byte = 0xA4
		self._create_can_message(cmd_byte, can_msg_inputs)

	def Single_turn_position_control_command(self, can_msg_inputs: list[int]) -> can.Message:
		cmd_byte = 0xA6
		self._create_can_message(cmd_byte, can_msg_inputs)

	def System_operating_mode_acquisition(self, can_msg_inputs: list[int]) -> can.Message:
		cmd_byte = 0x70
		self._create_can_message(cmd_byte, can_msg_inputs)

	def Motor_power_acquisition(self, can_msg_inputs: list[int]) -> can.Message:
		cmd_byte = 0x71
		self._create_can_message(cmd_byte, can_msg_inputs)

	def System_reset_command(self, can_msg_inputs: list[int]) -> can.Message:
		cmd_byte = 0x76
		self._create_can_message(cmd_byte, can_msg_inputs)

	def System_brake_release_command(self, can_msg_inputs: list[int]) -> can.Message:
		cmd_byte = 0x77
		self._create_can_message(cmd_byte, can_msg_inputs)

	def System_brake_lock_command(self, can_msg_inputs: list[int]) -> can.Message:
		cmd_byte = 0x78
		self._create_can_message(cmd_byte, can_msg_inputs)

	def System_runtime_read_command(self, can_msg_inputs: list[int]) -> can.Message:
		cmd_byte = 0xB1
		self._create_can_message(cmd_byte, can_msg_inputs)

	def System_software_version_date_read_command(self, can_msg_inputs: list[int]) -> can.Message:
		cmd_byte = 0xB2
		self._create_can_message(cmd_byte, can_msg_inputs)

	def Communication_baud_rate_setting_command(self, can_msg_inputs: list[int]) -> can.Message:
		cmd_byte = 0xB4
		self._create_can_message(cmd_byte, can_msg_inputs)

	def Motor_model_reading_command(self, can_msg_inputs: list[int]) -> can.Message:
		cmd_byte = 0xB5
		self._create_can_message(cmd_byte, can_msg_inputs)

	def Function_control_command(self, can_msg_inputs: list[int]) -> can.Message:
		cmd_byte = 0x20
		self._create_can_message(cmd_byte, can_msg_inputs)

