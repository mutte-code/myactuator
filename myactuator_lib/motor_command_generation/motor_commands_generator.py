# MyActuatorMotor.py
# By: Nathan Adkins 
# email: npa00003@mix.wvu.edu
# WVU URC 

import re

def main():

    def extract_func_name(line_string: str) -> str: # extracts and cleans the commands into function names 

        replacements = {
            '.' : '',
            ' ' : '_',
            '-' : '_',
            '__' : '_'
        }
        cleaned_string = re.sub(r'\d+|\([^)]*\)', '', line_string) # regex for digits, or text in parentheses

        for key,value in replacements.items(): # fulfilling all replacements for python method validity
            cleaned_string = cleaned_string.replace(key,value)

        cleaned_string = cleaned_string[1:-2] # removing first and last characters (both underscores)

        return cleaned_string
    
    
    def extract_can_hex(line_string: str) -> str:
        return (str(line_string[len(line_string)-5:len(line_string)-1])) # Taking just the byte portion of the string
    
    def create_valid_py_func(function_name: str) -> str: # add def, params, and return type
        return f'\tdef {function_name}(self, can_msg_inputs: list[int]) -> can.Message:\n'
    
    manual_file_path = 'myactuator_lib/motor_command_generation/manual_contents.txt'
    myactuator_manual_file = open(manual_file_path, 'r')

    generated_file_path = 'myactuator_lib/_MyActuatorMotorPrivate.py'
    generated_file = open(generated_file_path, 'w')

    method_pattern = r'^2\..*\s\(0x[0-9a-fA-F][0-9a-fA-F]\)$'
    can_hex_pattern = r'^DATA.*0x[0-9a-fA-F][0-9a-fA-F]$'

    read_lines = myactuator_manual_file.readlines()

    written_lines: list[str] = []

    # File Starting content
    written_lines.append('# This file was autogenerated by "motor_commands_generator.py" found under the "motor_command_generation" folder of "myactuator_lib"\n')
    written_lines.append('import can\n\n')
    written_lines.append('class _MyActuatorMotorPrivate():\n\n')
    written_lines.append('\tdef __init__(self, arbitration_id: int):\n')
    written_lines.append('\t\tminimum_id = 0x141\n')
    written_lines.append('\t\tmaximum_id = 0x172\n\n')
    written_lines.append('\t\tif (minimum_id < arbitration_id < maximum_id): \n')
    written_lines.append('\t\t\tself.arbitration_id = arbitration_id\n')
    written_lines.append('\t\telse:\n')
    written_lines.append('\t\t\traise ValueError(f"The arbitration id {arbitration_id} is invalid")\n\n')
    written_lines.append('\tdef _create_can_message(self, cmd_byte: int, can_data: list[int]) -> can.Message:\n\n')
    written_lines.append('\t\tif not (len(can_data) == 7): # need to populate 7 bytes only, check\n')
    written_lines.append('\t\t\traise ValueError\n\n')
    written_lines.append('\t\tfor byte in can_data:\n')
    written_lines.append('\t\t\tif not (0x00 <= byte <= 0xFF): # int not guaranteed to be within range of hex byte, check\n')
    written_lines.append('\t\t\t\traise ValueError\n\n')
    written_lines.append('\t\tcan_data = cmd_byte + can_data # construct can message, and return\n')
    written_lines.append('\t\treturn can.Message(\n')
    written_lines.append('\t\t\tarbitration_id = self.arbitration_id,\n')
    written_lines.append('\t\t\tis_extended_id = False,\n')
    written_lines.append('\t\t\tdata = can_data)\n\n')

    for index, line in enumerate(read_lines):

        if re.match(method_pattern,line): 

            valid_function_def = create_valid_py_func(extract_func_name(line))
            written_lines.append(valid_function_def)

            for internal_line in read_lines[index:]:
                if re.match(can_hex_pattern,internal_line):
                    hex_byte = extract_can_hex(internal_line)
                    if hex_byte != '0x00':
                        written_lines.append(f'\t\tcmd_byte = {hex_byte}\n')
                    break
                    
            written_lines.append(f'\t\tself._create_can_message(cmd_byte, can_msg_inputs)\n\n')

    generated_file.writelines(written_lines)

if __name__ == '__main__':
    main()